r"""
Data compiled by Riri (https://github.com/AlinaWan). Attribution is not required, but it's appreciated if you found this useful.
------------------------------------------------------------

Script: Exponential Decay Curve Fitting for Inventory Walkspeed Penalty
Author: Riri (https://github.com/AlinaWan) | Partially generated by Gemini 2.5 Flash and GPT-4o-mini
Date: July 4, 2025
License: WTFPL (Attribution is appreciated though!)

Description:
This script performs non-linear curve fitting to model a "walkspeed penalty" as a function of
inventory items. It uses a custom function defined as a sum of two exponential decay terms
with a crucial constraint: the function must start at y=0 when x = 35, and immediately jump 
to 30% penalty between 35 < x ≤ 50. This range is **explicitly hardcoded** and overrides the
function output — no offsets or plateaus are built into the model itself.

This models a scenario where a threshold sharply activates a penalty, holds briefly, and then
gradually increases beyond x = 50 through curve fitting.

The script performs the following steps:
1.  **Data Definition**: Defines `x_data` (number of inventory items) and `y_target`
    (corresponding walkspeed penalty as a decimal).
2.  **Custom Function (`sum_two_exponentials_constrained`)**:
    * Implements the equation:
        $$
        y(x) = A - B_1 \cdot e^{-C_1 \cdot \max(0, x - 35)} - B_2 \cdot e^{-C_2 \cdot \max(0, x - 35)}
        $$
    * Applies a constraint $B_2 = A - B_1$ to ensure that $y(35) = 0$.
    * Exponential decay only activates after x > 35.
    * Includes overflow protection for very large exponents.
3.  **Hardcoded Override**:
    * After fitting, y-values for 35 < x ≤ 50 are manually overridden to 0.30.
4.  **Parameter Initialization**: Uses defined initial guesses (`p0`) and parameter bounds.
5.  **Curve Fitting**: Uses `scipy.optimize.curve_fit` to fit the model to the data.
6.  **Results Output**:
    * Prints optimal parameters and Sum of Squared Errors (SSE).
    * Outputs the equation in LaTeX using a piecewise format.
7.  **Plotting**:
    * Shows the overall fit and individual exponential decay components.
8.  **Error Handling**: Catches `RuntimeError` and `ValueError` during the fitting process.

------------------------------------------------------------
Output:

Attempting fit with Sum of Two Exponentials. Initial Guesses: [1.0, 0.8, 0.025, 0.00015]
Parameter Bounds: Lower [0.98, 0.001, 0.001, 1e-05], Upper [1.05, 0.99, 0.1, 0.005]

--- Optimized Fit Results (Sum of Two Exponentials) ---
Optimal Parameters (A, B1, C1, C2): 0.9900, 0.6065, 0.0388, 0.005000
Sum of Squared Errors (SSE): 0.002034

--- The Fitted Equation (in LaTeX Format) ---
$$
    y(x) =
    \begin{cases}
        0, & \text{if } x \leq 35 \\
        0.30, & \text{if } 35 < x \leq 50 \\
        0.9900 - 0.6065 \cdot e^{-0.0388 \cdot (x - 35)} - 0.3835 \cdot e^{-0.005000 \cdot (x - 35)}, & \text{if } x > 50
    \end{cases}
    $$
------------------------------------------------------------
QuickLaTex image: https://quicklatex.com/cache3/8c/ql_54151c90a51416cb26ffa36bcdc5d88c_l3.png
"""
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit

# --- Input data compiled by Riri (https://github.com/AlinaWan). Attribution is not required, but it's appreciated if you found this useful.
x_data = np.array([35, 36, 45, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 64, 65, 66, 67, 68, 70, 71, 73, 74, 76, 135, 138, 143, 149, 156, 163, 171, 181, 192, 202, 213, 226, 242, 261, 280, 321, 342, 369, 2076, 5026]) # Number of items in the player's inventory. The player can hold 35 items before their walkspeed is penalized. The penalty starts at 0.30. For accuracy and simplicity, we hard code the penalty for the values between 35 and 50 to 0.30 (see module docstring).
y_target = np.array([0, 0.30, 0.30, 0.30, 0.31, 0.33, 0.34, 0.35, 0.36, 0.38, 0.39, 0.40, 0.41, 0.42, 0.43, 0.44, 0.45, 0.46, 0.47, 0.48, 0.49, 0.50, 0.51, 0.52, 0.53, 0.54, 0.74, 0.75, 0.76, 0.77, 0.78, 0.79, 0.80, 0.81, 0.82, 0.83, 0.84, 0.85, 0.86, 0.87, 0.88, 0.89, 0.90, 0.91, 0.98, 0.99]) # The walkspeed penalty as a decimal.

x_start = 35

# --- Custom Function: sum of 2 exponentials, constrained so y(35)=0
def sum_two_exponentials_constrained(x, A, B1, C1, C2):
    x = np.asarray(x)
    x_shifted = np.maximum(x - x_start, 0)
    B2 = A - B1
    term1 = np.where(C1 * x_shifted > 700, 0.0, B1 * np.exp(-C1 * x_shifted))
    term2 = np.where(C2 * x_shifted > 700, 0.0, B2 * np.exp(-C2 * x_shifted))
    return A - term1 - term2

# --- Initial Guess & Bounds
p0 = [1.0, 0.8, 0.025, 0.00015]
bounds = (
    [0.98, 0.001, 0.001, 0.00001],
    [1.05, 0.99, 0.1, 0.005]
)

print(f"Attempting fit with Sum of Two Exponentials. Initial Guesses: {p0}")
print(f"Parameter Bounds: Lower {bounds[0]}, Upper {bounds[1]}")

try:
    params, _ = curve_fit(sum_two_exponentials_constrained, x_data, y_target, p0=p0, bounds=bounds, maxfev=5000)
    A_opt, B1_opt, C1_opt, C2_opt = params
    B2_opt = A_opt - B1_opt

    # --- Generate fitted values
    y_fitted = sum_two_exponentials_constrained(x_data, A_opt, B1_opt, C1_opt, C2_opt)

    # --- Apply 30% override for 35 < x <= 50
    override_mask = (x_data > 35) & (x_data <= 50)
    y_fitted[override_mask] = 0.30

    sse = np.sum((y_target - y_fitted) ** 2)

    print("\n--- Optimized Fit Results (Sum of Two Exponentials) ---")
    print(f"Optimal Parameters (A, B1, C1, C2): {A_opt:.4f}, {B1_opt:.4f}, {C1_opt:.4f}, {C2_opt:.6f}")
    print(f"Sum of Squared Errors (SSE): {sse:.6f}")

    # --- LaTeX representation with hardcoded region
    latex_equation = f"""$$
    y(x) =
    \\begin{{cases}}
        0, & \\text{{if }} x \\leq 35 \\\\
        0.30, & \\text{{if }} 35 < x \\leq 50 \\\\
        {A_opt:.4f} - {B1_opt:.4f} \\cdot e^{{-{C1_opt:.4f} \\cdot (x - 35)}} - {B2_opt:.4f} \\cdot e^{{-{C2_opt:.6f} \\cdot (x - 35)}}, & \\text{{if }} x > 50
    \\end{{cases}}
    $$"""
    print("\n--- The Fitted Equation (in LaTeX Format) ---")
    print(latex_equation)

    # --- Plot total fit
    x_fit = np.linspace(x_data.min() - 20, x_data.max() + 500, 500)
    y_fit = sum_two_exponentials_constrained(x_fit, A_opt, B1_opt, C1_opt, C2_opt)
    y_fit[(x_fit > 35) & (x_fit <= 50)] = 0.30

    plt.figure(figsize=(12, 7))
    plt.scatter(x_data, y_target, label='Original Data', color='red', s=50, zorder=5)
    plt.plot(x_fit, y_fit, label=f'Fitted Curve (SSE: {sse:.4f})', color='blue', linewidth=2)
    plt.title('Walkspeed Penalty Curve Fit (Hardcoded 30% for 35 < x ≤ 50)')
    plt.xlabel('Inventory Item Count')
    plt.ylabel('Walkspeed Penalty')
    plt.grid(True)
    plt.legend()
    plt.ylim(-0.05, 1.05)
    plt.xlim(x_data.min() - 20, x_data.max() + 1000)
    plt.show()

    # --- Plot component breakdown
    plt.figure(figsize=(12, 7))
    plt.scatter(x_data, y_target, label='Original Data', color='red', s=50, zorder=5)
    plt.plot(x_fit, y_fit, label='Total Fit', color='blue', linestyle='--', linewidth=2)

    decay_x = x_fit[x_fit > 50] - x_start
    term1 = B1_opt * np.exp(-C1_opt * decay_x)
    term2 = B2_opt * np.exp(-C2_opt * decay_x)

    plt.plot(x_fit[x_fit > 50], A_opt - term1, label='Component 1 (Faster)', color='green', linestyle=':', alpha=0.7)
    plt.plot(x_fit[x_fit > 50], A_opt - term2, label='Component 2 (Slower)', color='orange', linestyle=':', alpha=0.7)

    plt.title('Component Breakdown of Exponential Fit')
    plt.xlabel('Inventory Item Count')
    plt.ylabel('Walkspeed Penalty')
    plt.grid(True)
    plt.legend()
    plt.ylim(-0.05, 1.05)
    plt.xlim(x_data.min() - 20, x_data.max() + 1000)
    plt.show()

except RuntimeError as e:
    print(f"Error fitting curve: {e}")
except ValueError as e:
    print(f"Value Error: {e}")
