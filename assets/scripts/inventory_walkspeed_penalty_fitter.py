"""
Data compiled by Riri (https://github.com/AlinaWan). Attribution is not required, but it's appreciated if you found this useful.
------------------------------------------------------------

Script: Exponential Decay Curve Fitting for Inventory Walkspeed Penalty
Author: Riri (https://github.com/AlinaWan) | Partially generated by Gemini 2.5 Flash
Date: July 4, 2025
License: WTFPL (Attribution is appreciated though!)

Description:
This script performs non-linear curve fitting to model a "walkspeed penalty" as a function of
inventory items. It uses a custom function defined as a sum of two exponential decay terms
with a crucial constraint: the function must start at y=0 when x equals a specified
starting point (`x_start`). This models a scenario where the penalty only begins after
a certain inventory threshold is reached.

The script performs the following steps:
1.  **Data Definition**: Defines `x_data` (number of inventory items) and `y_target`
    (corresponding walkspeed penalty as a decimal).
2.  **Custom Function (`sum_two_exponentials_constrained`)**:
    * Implements the equation:
        $$y(x) = A - B_1 \cdot e^{-C_1 \cdot \max(0, x - x_{start})} - B_2 \cdot e^{-C_2 \cdot \max(0, x - x_{start})}$$
    * Applies a constraint $B_2 = A - B_1$ to ensure that $y(x_{start}) = 0$.
    * Includes `np.maximum(x_shifted, 0)` to ensure that the exponential decay only
        starts when `x` is greater than `x_start`.
    * Adds handling for very large exponents to prevent `OverflowError`.
3.  **Parameter Initialization**: Sets initial guesses (`p0`) and bounds for the
    parameters (A, B1, C1, C2) to guide the fitting process.
4.  **Curve Fitting**: Uses `scipy.optimize.curve_fit` to find the optimal parameters
    that best fit the `x_data` to `y_target` using the custom function.
5.  **Results Output**:
    * Prints the optimal parameters (A, B1, C1, C2) and the calculated B2.
    * Calculates and prints the Sum of Squared Errors (SSE) to evaluate the fit quality.
    * Generates and prints the fitted equation in LaTeX format, which can be
        directly used in LaTeX-enabled environments.
6.  **Plotting**:
    * Generates two plots:
        * The first plot shows the original data points and the overall fitted curve.
        * The second plot additionally shows the individual contributions of the
            two exponential components to the overall fit, providing insight into
            their respective decay rates.
7.  **Error Handling**: Includes `try-except` blocks to catch potential `RuntimeError`
    (e.g., if the optimizer fails to converge) or `ValueError` during the fitting process.

------------------------------------------------------------
Output:

Attempting fit with Sum of Two Exponentials. Initial Guesses: [1.0, 0.8, 0.025, 0.00015]
Parameter Bounds: Lower [0.98, 0.001, 0.001, 1e-05], Upper [1.05, 0.99, 0.1, 0.005]

--- Optimized Fit Results (Sum of Two Exponentials) ---
Optimal Parameters (A, B1, C1, C2): 0.9850, 0.7152, 0.0250, 0.003807
Sum of Squared Errors (SSE): 0.000101

--- The Fitted Equation (in LaTeX Format) ---
$$y(x) = 0.9850 - 0.7152 \cdot e^{-0.0250 \cdot \max(0, x - 35)} - 0.2698 \cdot e^{-0.003807 \cdot \max(0, x - 35)}$$
 (Copy this LaTeX code into a LaTeX-enabled environment for rendering.)
"""
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit

# --- Data compiled by Riri (https://github.com/AlinaWan). Attribution is not required, but it's appreciated if you found this useful.
x_data = np.array([35, 135, 138, 143, 149, 156, 163, 171, 181, 192, 202, 213, 226, 242, 261, 280, 321, 342, 369, 2076, 5026]) # number of items in the inventory
y_target = np.array([0, 0.74, 0.75, 0.76, 0.77, 0.78, 0.79, 0.80, 0.81, 0.82, 0.83, 0.84, 0.85, 0.86, 0.87, 0.88, 0.89, 0.90, 0.91, 0.98, 0.99]) # walkspeed penalty as a decimal

x_start = x_data[0] # The x-value where y is 0

# --- Custom Function: Sum of Two Exponentials with x-shift and y(x_start)=0 constraint ---
# y(x) = A - B1 * exp(-C1 * (x - x_start)) - B2 * exp(-C2 * (x - x_start))
# Constraint: B2 = A - B1 (to ensure y(x_start) = 0)
def sum_two_exponentials_constrained(x, A, B1, C1, C2):
    x_shifted = x - x_start
    # Make sure shifted x is non-negative for exp decay meaning
    x_shifted = np.maximum(x_shifted, 0) # This is crucial for the (35,0) start

    B2 = A - B1 # Apply the constraint

    # Handle potential issues with very large exponents, which can cause OverflowError
    term1 = np.where(C1 * x_shifted > 700, 0.0, B1 * np.exp(-C1 * x_shifted)) # If C*x is very large, exp is effectively 0
    term2 = np.where(C2 * x_shifted > 700, 0.0, B2 * np.exp(-C2 * x_shifted))

    return A - term1 - term2

# --- Initial Guesses (Crucial for multi-component functions) ---
A_guess = 1.0
B1_guess = 0.8
C1_guess = 0.025
C2_guess = 0.00015

p0 = [A_guess, B1_guess, C1_guess, C2_guess]

# Define bounds for parameters
bounds = (
    [0.98, 0.001, 0.001, 0.00001], # Lower bounds: A, B1, C1, C2
    [1.05, 0.99, 0.1, 0.005]    # Upper bounds: A, B1, C1, C2. C1 should be larger than C2
)

print(f"Attempting fit with Sum of Two Exponentials. Initial Guesses: {p0}")
print(f"Parameter Bounds: Lower {bounds[0]}, Upper {bounds[1]}")

try:
    params, covariance = curve_fit(sum_two_exponentials_constrained, x_data, y_target, p0=p0, bounds=bounds, maxfev=5000)
    A_opt, B1_opt, C1_opt, C2_opt = params

    y_fitted = sum_two_exponentials_constrained(x_data, A_opt, B1_opt, C1_opt, C2_opt)
    sse = np.sum((y_target - y_fitted)**2)

    print("\n--- Optimized Fit Results (Sum of Two Exponentials) ---")
    print(f"Optimal Parameters (A, B1, C1, C2): {A_opt:.4f}, {B1_opt:.4f}, {C1_opt:.4f}, {C2_opt:.6f}")
    print(f"Sum of Squared Errors (SSE): {sse:.6f}")

    B2_opt = A_opt - B1_opt

    # --- Print the equation in LaTeX format ---
    # This LaTeX equation *must* also include \max(0, ...) to match the behavior
    latex_equation = (
        f"$$y(x) = {A_opt:.4f} - {B1_opt:.4f} \\cdot e^{{-{C1_opt:.4f} \\cdot \\max(0, x - {x_start})}} - {B2_opt:.4f} \\cdot e^{{-{C2_opt:.6f} \\cdot \\max(0, x - {x_start})}}$$ "
    )
    print("\n--- The Fitted Equation (in LaTeX Format) ---")
    print(latex_equation)
    print(" (Copy this LaTeX code into a LaTeX-enabled environment for rendering.)")


    # Plotting the result (your existing plotting code)
    plt.figure(figsize=(12, 7))
    plt.scatter(x_data, y_target, label='Original Data', color='red', s=50, zorder=5)

    # For plotting, we use the numpy function which internally handles the max(0,...)
    x_fit = np.linspace(x_data.min() - 100, x_data.max() + 500, 500) # Extend x range to show (35,0) clearly
    y_fit = sum_two_exponentials_constrained(x_fit, A_opt, B1_opt, C1_opt, C2_opt)
    plt.plot(x_fit, y_fit, label=f'Sum of Two Exponentials Fit (SSE: {sse:.4f})', color='blue', linewidth=2)

    plt.title('Custom Function Fit: Sum of Two Exponentials')
    plt.xlabel('x')
    plt.ylabel('y')
    plt.legend()
    plt.grid(True)
    plt.ylim(-0.05, 1.05)
    plt.xlim(x_data.min() - 100, x_data.max() + 1000) # Adjust x-lim to clearly show behavior before x_start
    plt.show()

    # Optional: Plot individual components
    plt.figure(figsize=(12, 7))
    plt.scatter(x_data, y_target, label='Original Data', color='red', s=50, zorder=5)
    plt.plot(x_fit, sum_two_exponentials_constrained(x_fit, A_opt, B1_opt, C1_opt, C2_opt),
             label='Overall Fit', color='blue', linewidth=2, linestyle='--')

    term1_contrib = B1_opt * np.exp(-C1_opt * (x_fit - x_start))
    term2_contrib = (A_opt - B1_opt) * np.exp(-C2_opt * (x_fit - x_start))

    plt.plot(x_fit, A_opt - term1_contrib, label='Component 1 (Faster)', color='green', linestyle=':', alpha=0.7)
    plt.plot(x_fit, A_opt - term2_contrib, label='Component 2 (Slower)', color='orange', linestyle=':', alpha=0.7)
    plt.title('Custom Function Fit with Individual Components')
    plt.xlabel('x')
    plt.ylabel('y')
    plt.legend()
    plt.grid(True)
    plt.ylim(-0.05, 1.05)
    plt.xlim(x_data.min() - 100, x_data.max() + 1000)
    plt.show()

except RuntimeError as e:
    print(f"Error fitting curve: {e}. This often means the optimizer struggled to converge.")
    print("Consider adjusting initial guesses (p0) or bounds, or trying a different function form.")
except ValueError as e:
    print(f"Value Error: {e}. This might happen if bounds are too restrictive or lead to impossible values.")